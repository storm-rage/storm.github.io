(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{300:function(t,a,s){"use strict";s.r(a);var e=s(14),r=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"高级技能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高级技能"}},[t._v("#")]),t._v(" 高级技能")]),t._v(" "),a("ul",[a("li",[t._v("使用前端工程化思维开发")]),t._v(" "),a("li",[t._v("JavaScript对DOM操作的各种方式与性能开销")]),t._v(" "),a("li",[t._v("熟悉RESTful架构、跨域等技术")]),t._v(" "),a("li",[t._v("能对代码进行良好的性能优化")]),t._v(" "),a("li",[t._v("了解常用框架功能原理的代码实现")]),t._v(" "),a("li",[t._v("熟悉前端开发的一些安全问题")]),t._v(" "),a("li",[t._v("熟悉常见跨浏览器问题")]),t._v(" "),a("li",[t._v("了解必要的计算机网络协议")]),t._v(" "),a("li",[t._v("熟悉JavaScript的前后端开发")]),t._v(" "),a("li",[t._v("熟悉各种开发设计模式")]),t._v(" "),a("li",[t._v("了解前端的一些测试方法")])]),t._v(" "),a("h2",{attrs:{id:"_1-如何解决回调层级过深的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-如何解决回调层级过深的问题"}},[t._v("#")]),t._v(" 1. 如何解决回调层级过深的问题？")]),t._v(" "),a("p",[t._v("回调层级过深，即回调地狱，用回调函数的方式来处理多个串行的异步操作，会造成嵌套很深的情况。")]),t._v(" "),a("h3",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),a("ol",[a("li",[t._v("promise")])]),t._v(" "),a("ul",[a("li",[t._v("用promise可以将串行的异步，处理成链式调用。")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("async/await")])]),t._v(" "),a("ul",[a("li",[t._v("async/await比用promise更优雅。")]),t._v(" "),a("li",[t._v("async/await是Generator的语法糖。")]),t._v(" "),a("li",[t._v("async/await是Promise的语法糖。")]),t._v(" "),a("li",[t._v("async/await是Generator和Promise的语法糖。")])]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("generator")])]),t._v(" "),a("ul",[a("li",[t._v("generator是ES6提供的一种异步编程解决方案。")]),t._v(" "),a("li",[t._v("generator可以暂停函数的执行，返回任意表达式的值。")]),t._v(" "),a("li",[t._v("generator可以通过next方法恢复函数的执行。")]),t._v(" "),a("li",[t._v("generator可以通过throw方法抛出异常。")]),t._v(" "),a("li",[t._v("generator可以通过return方法返回值。")]),t._v(" "),a("li",[t._v("generator可以通过yield关键字暂停函数的执行，返回任意表达式的值。")]),t._v(" "),a("li",[t._v("generator可以通过next方法恢复函数的执行。")])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("事件监听")]),t._v(" "),a("li",[t._v("发布/订阅")]),t._v(" "),a("li",[t._v("MutationObserver")]),t._v(" "),a("li",[t._v("微任务")]),t._v(" "),a("li",[t._v("宏任务")])]),t._v(" "),a("h2",{attrs:{id:"_2-cors跨域的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-cors跨域的原理"}},[t._v("#")]),t._v(" 2. CORS跨域的原理？")]),t._v(" "),a("p",[t._v("跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。")]),t._v(" "),a("h3",{attrs:{id:"解决方案-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),a("ol",[a("li",[t._v("JSONP")]),t._v(" "),a("li",[t._v("CORS")]),t._v(" "),a("li",[t._v("postMessage")]),t._v(" "),a("li",[t._v("WebSocket")]),t._v(" "),a("li",[t._v("Nodejs中间件代理")]),t._v(" "),a("li",[t._v("Nginx反向代理")]),t._v(" "),a("li",[t._v("document.domain + iframe")]),t._v(" "),a("li",[t._v("location.hash + iframe")]),t._v(" "),a("li",[t._v("window.name + iframe")]),t._v(" "),a("li",[t._v("window.postMessage")]),t._v(" "),a("li",[t._v("跨子域的通信")]),t._v(" "),a("li",[t._v("跨文档通信（Cross-document messaging）")]),t._v(" "),a("li",[t._v("预检请求（Preflighted requests）")]),t._v(" "),a("li",[t._v("服务器端设置Access-Control-Allow-Origin")]),t._v(" "),a("li",[t._v("跨浏览器的CORS")])]),t._v(" "),a("h2",{attrs:{id:"_3-谈谈各种本地存储方案的优势与弊端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-谈谈各种本地存储方案的优势与弊端"}},[t._v("#")]),t._v(" 3. 谈谈各种本地存储方案的优势与弊端？")]),t._v(" "),a("ol",[a("li",[t._v("cookie")]),t._v(" "),a("li",[t._v("localStorage")]),t._v(" "),a("li",[t._v("sessionStorage")])]),t._v(" "),a("h2",{attrs:{id:"_4-js延迟加载的方式有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-js延迟加载的方式有哪些"}},[t._v("#")]),t._v(" 4. JS延迟加载的方式有哪些？")]),t._v(" "),a("h3",{attrs:{id:"_1-defer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-defer"}},[t._v("#")]),t._v(" 1). defer")]),t._v(" "),a("p",[t._v("defer属性只适用于外部脚本文件。")]),t._v(" "),a("h3",{attrs:{id:"_2-async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-async"}},[t._v("#")]),t._v(" 2). async")]),t._v(" "),a("p",[t._v("async属性只适用于外部脚本文件。")]),t._v(" "),a("h3",{attrs:{id:"_3-动态创建dom方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-动态创建dom方式"}},[t._v("#")]),t._v(" 3). 动态创建DOM方式")]),t._v(" "),a("h3",{attrs:{id:"_4-使用settimeout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-使用settimeout"}},[t._v("#")]),t._v(" 4). 使用setTimeout")]),t._v(" "),a("h3",{attrs:{id:"_5-使用sse"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-使用sse"}},[t._v("#")]),t._v(" 5). 使用SSE")]),t._v(" "),a("h3",{attrs:{id:"_6-使用ajax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-使用ajax"}},[t._v("#")]),t._v(" 6). 使用Ajax")]),t._v(" "),a("h3",{attrs:{id:"_7-使用动态脚本元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-使用动态脚本元素"}},[t._v("#")]),t._v(" 7). 使用动态脚本元素")]),t._v(" "),a("h3",{attrs:{id:"_8-使用es6的import"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-使用es6的import"}},[t._v("#")]),t._v(" 8). 使用ES6的import()")]),t._v(" "),a("h3",{attrs:{id:"_9-使用promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-使用promise"}},[t._v("#")]),t._v(" 9). 使用Promise")]),t._v(" "),a("h3",{attrs:{id:"_10-使用async-await"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-使用async-await"}},[t._v("#")]),t._v(" 10). 使用async/await")]),t._v(" "),a("h3",{attrs:{id:"_11-使用mutationobserver"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-使用mutationobserver"}},[t._v("#")]),t._v(" 11). 使用MutationObserver")]),t._v(" "),a("h3",{attrs:{id:"_12-使用document-write"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-使用document-write"}},[t._v("#")]),t._v(" 12). 使用document.write()")]),t._v(" "),a("h3",{attrs:{id:"_13-使用document-createelement"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-使用document-createelement"}},[t._v("#")]),t._v(" 13). 使用document.createElement()")]),t._v(" "),a("ol",[a("li",[t._v("async")]),t._v(" "),a("li",[t._v("defer")])]),t._v(" "),a("h2",{attrs:{id:"_5-哪些操作会造成内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-哪些操作会造成内存泄漏"}},[t._v("#")]),t._v(" 5. 哪些操作会造成内存泄漏？")]),t._v(" "),a("p",[t._v("什么是内存泄漏？\n内存泄漏指任何对象在不再拥有或需要它之后却仍然存在。JavaScript中的内存泄漏大部分是由不合理的引用导致的。")]),t._v(" "),a("h3",{attrs:{id:"_1-意外声明全局变量是最常见也最容易修复的内存泄漏问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-意外声明全局变量是最常见也最容易修复的内存泄漏问题"}},[t._v("#")]),t._v(" 1).意外声明全局变量是最常见也最容易修复的内存泄漏问题")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'lucy'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("解释器在解释上面的函数时，会把name当做全局变量，即window.name = '张三'。只要window对象没有被清理，那么name属性和属性值将一直存在，造成内存泄露\n解决方法：")]),t._v(" "),a("ol",[a("li",[t._v("只要在变量声明前面加上var、let或const关键字即可，这样变量就会在函数执行完毕后离开作用域。")]),t._v(" "),a("li",[t._v("使用this关键字")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'lucy'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("可以在 JavaScript 文件开头添加 “use strict”，使用严格模式。这样在严格模式下解析 JavaScript 可以防止意外的全局变量")]),t._v(" "),a("li",[t._v("在使用完之后，对其赋值为null或者重新分配")])]),t._v(" "),a("h3",{attrs:{id:"_2-定时器导致的泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-定时器导致的泄漏"}},[t._v("#")]),t._v(" 2).定时器导致的泄漏")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'mick'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setInterval")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("只要定时器一直运行，回调函数中引用的name就一直占用内存。")]),t._v(" "),a("h3",{attrs:{id:"_3-闭包、控制台日志、循环-两个对象彼此引用且彼此保留时-就会产生一个循环-如下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-闭包、控制台日志、循环-两个对象彼此引用且彼此保留时-就会产生一个循环-如下"}},[t._v("#")]),t._v(" 3).闭包、控制台日志、循环（两个对象彼此引用且彼此保留时，就会产生一个循环），如下")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("fun")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'jack'")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" name\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("调用fun()会导致分配给name的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理name，因为闭包一致再引用着它。")]),t._v(" "),a("h2",{attrs:{id:"_6-写一个通用的事件侦听器函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-写一个通用的事件侦听器函数"}},[t._v("#")]),t._v(" 6. 写一个通用的事件侦听器函数？")]),t._v(" "),a("p",[t._v("function addEvent(element, type, handler) {\nif (element.addEventListener) {\nelement.addEventListener(type, handler, false)\n} else if (element.attachEvent) {\nelement.attachEvent('on' + type, handler)\n} else {\nelement['on' + type] = handler\n}\n}\nfunction removeEvent(element, type, handler) {\nif (element.removeEventListener) {\nelement.removeEventListener(type, handler, false)\n} else if (element.detachEvent) {\nelement.detachEvent('on' + type, handler)\n} else {\nelement['on' + type] = null\n}\n}")]),t._v(" "),a("h2",{attrs:{id:"_7-介绍一下xss和csrf的原理和防范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-介绍一下xss和csrf的原理和防范"}},[t._v("#")]),t._v(" 7. 介绍一下XSS和CSRF的原理和防范？")]),t._v(" "),a("h2",{attrs:{id:"_8-如何实现一个简易的模块管理库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-如何实现一个简易的模块管理库"}},[t._v("#")]),t._v(" 8. 如何实现一个简易的模块管理库？")]),t._v(" "),a("h2",{attrs:{id:"_9-介绍for-in的技术细节与性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-介绍for-in的技术细节与性能问题"}},[t._v("#")]),t._v(" 9. 介绍for in的技术细节与性能问题？")]),t._v(" "),a("p",[t._v("可以用来遍历对象的可枚举属性（包括自身属性和继承的属性）。然而，使用 for...in 也存在一些技术细节和性能问题")]),t._v(" "),a("ol",[a("li",[t._v("遍历顺序：for...in 循环的遍历顺序是不确定的，它取决于 JavaScript 引擎的实现。因此，在使用 for...in 进行遍历时，无法保证属性的遍历顺序是一致的。")]),t._v(" "),a("li",[t._v("遍历原型链属性：for...in 循环会遍历对象的原型链上的可枚举属性。这意味着它不仅会遍历对象自身的属性，还会遍历继承的属性。如果只希望遍历对象自身的属性，而不包括继承的属性，可以通过使用 hasOwnProperty 方法进行判断。")]),t._v(" "),a("li",[t._v("包括非数字属性：for...in 循环会遍历对象的所有可枚举字符串属性，包括数字形式的字符串属性。例如，对于数组对象，for...in 循环会遍历数组的原型链上的所有可枚举属性，包括数组的原型方法和索引值。这通常不是预期的遍历方式。")]),t._v(" "),a("li",[t._v("性能问题：由于 for...in 循环需要遍历对象的所有属性，包括原型链上的属性，并且无法保证遍历顺序，因此在大型对象或嵌套对象上进行 for...in 循环可能会导致性能问题。每次迭代都需要对属性进行检查，并且需要额外的遍历操作。对于大型数据集合，可以考虑使用其他更高效的遍历方法，如 forEach、for...of 等")])]),t._v(" "),a("h2",{attrs:{id:"_10-谈谈js的满加载和断点续调问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-谈谈js的满加载和断点续调问题"}},[t._v("#")]),t._v(" 10. 谈谈JS的满加载和断点续调问题？")]),t._v(" "),a("h2",{attrs:{id:"_11-如何实现js的依赖注入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-如何实现js的依赖注入"}},[t._v("#")]),t._v(" 11. 如何实现JS的依赖注入？")]),t._v(" "),a("h2",{attrs:{id:"_12-如何处理高并发请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-如何处理高并发请求"}},[t._v("#")]),t._v(" 12. 如何处理高并发请求？")]),t._v(" "),a("h2",{attrs:{id:"_13-nexttick实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-nexttick实现原理"}},[t._v("#")]),t._v(" 13. nextTick实现原理？")]),t._v(" "),a("p",[t._v("vue采用异步更新策略，当监听到数据发生变化时不会立即去更新dom，而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更；\n这样的好处是可以蒋多次数据更新合并成一次，从而减少dom操作次数，如果不采用这种方法，数据改变100次就要去更新100次dom，消耗更多性能。\nnextTick接受一个回调函数作为参数，并将回调函数延迟到dom更新后才执行。【使用场景】想要操作基于最新数据生成的dom时，可以放在nextTick的回调函数中。")])])}),[],!1,null,null,null);a.default=r.exports}}]);